---
layout: post
title: WSL下ESP32开发环境的搭建
date: 2019-7-26 22:00
comments: true
categories: 技术
---

![](https://docs.espressif.com/projects/esp-idf/zh_CN/latest/_images/esp32-devkitc-functional-overview.jpg)

感觉应该挺简单一事儿，结果历经坎坷，最终终于完成。

### 为什么不用WIN环境

不是不想，是有问题，特别是结合powershell一起用的情况下，各种坑，选择放弃。

### 为什么是WSL而不是虚拟机

WIN环境下的linux开发，强烈推荐WSL，配合powershell(也即cmder)一起，有一种winux(win + linux)的感觉，如鱼得水，非常棒。当然了WSL也有它的问题，比如IO效率差，不支持桌面环境，不支持显卡设备之类的，甚至一般的设备驱动都可能存在问题。但是绝大部分的情况下，我是强烈推荐使用的。同一个shell下面，既可执行linux的命令，也可以运行window命令，既可以访问linux目录，也可以访问window目录，融为了一体，这不是简单一个虚拟机共享文件夹可以有的体验。

虚拟机是物理层级的抽象，上面的linux环境就是一个真实linux环境，加上当前CPU对各种虚拟化指令的加持，使得虚拟机性能非常高(几乎和宿主一样高)。WSL是系统调用层级的抽象，然后在上面跑一套修改过的kernel。还有一个与开发相关的点是守护进程管理，WSL不支持systemd，但是也提供了一套类似的机制，并不完备，所以使用某些服务的时候会有一些坑。关于WSL的细节，可以参考[这里](https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/)；

再说一说WSL2。WSL官方实锤是已经放弃了，马上要出WSL2：基于Hyper-V虚拟技术实现的linux子系统。说白了，就是挂一个虚拟机，然后上面跑完整的linux环境。虽然叫WSL2，但是与WSL是完全不一样的东西。那么问题来了，我vmware，virtualBox用的好好的，为啥要用你巨硬的Hyper-V？所以，我的态度是观望。

### 安装步骤

安装步骤官方有详细的说明，请参考[这里](https://docs.espressif.com/projects/esp-idf/zh_CN/latest/get-started/index.html#get-started-step-by-step)，按照里面linux环境的方式来配置即可，这里主要是记录下碰到的问题。

### 问题


    解决一时爽，一直解决一直爽？不存在的，都是在浪费时间。
                                        
                                        ———— Ash

#### 1、 cmder下进入wsl后vim的方向键失灵

看问题的标题就感觉很纠结，但是google发现还是非常多人说这个问题，看来cmder+wsl是很多人的菜。解决问题的方法是修改cmder的配置如下图：

![](http://pic.ashliu.com/20190726135558.png)

看红框所示的意思是：启动bash的时候，带入```~ -cur_console:p5```参数p5是解决问题的关键，其他人说用的什么p:n都不行。

#### 2、idf.py无法使用串口，提示```termios.error: (5, 'Input/output error')```

使用idfdownload和monitor都会报这个错误，问题的原因是silicon lab的usb驱动有问题，这里说的是win环境的驱动。到pololu官网下载它的cp2102驱动，在[这里](https://www.pololu.com/file/0J14/pololu-cp2102-windows-121204.zip)，安装新驱动即可。

#### 3、idf.py依然无法下载的问题

按照上面操作后，串口看起来是没问题的，包括monitor命令都可以正常运行。但是下载死活不行，我怀疑是wsl对串口的驱动依然存在某些问题。昨天就卡在了这里，毫无进展一度准备放弃，最后准备直接用window的GUI工具实现下载得了。  

今天在用GUI工具过程中想到了解决方案：wsl支持运行exe，可以用esptool.exe代替esptool.py，从而走win的下载方式，同时又和linux环境是整合一起的，真是妙！

说干就干，实现其实非常简单了，把idf.py指向的下载命令，替换为esptool.exe：

{% highlight python %}
def flash(action, ctx, args):
    """
    Run esptool to flash the entire project, from an argfile generated by the build system
    """
    flasher_args_path = {  # action -> name of flasher args file generated by build system
        "bootloader-flash": "flash_bootloader_args",
        "partition_table-flash": "flash_partition_table_args",
        "app-flash": "flash_app_args",
        "flash": "flash_project_args",
        "encrypted-app-flash": "flash_encrypted_app_args",
        "encrypted-flash": "flash_encrypted_project_args",
    }[
        action
    ]

    # ash modify here
    # Use windows env's esptool.exe
    esptool_args = _get_esptool_args(args)
    esptool_args[1] = os.path.join(
        os.environ["IDF_PATH"], "components/esptool_py/esptool/esptool.exe"
    )
    esptool_args += ["write_flash", "@" + flasher_args_path]
    _run_tool("esptool.py", esptool_args[1:], args.build_dir)
{% endhighlight %}
 
其中，```_run_tool```函数的第二个参数是执行的命令(subprocess.check_call的调用，所以是列表格式)，去掉第一个是因为其默认用的python解析器，而我们需要直接执行exe；

这样就可以直接用idf.py实现载，传递的串口要注意是win下的：```COM3``` ， 而不是wsl下的：``` /dev/ttyS3 ```;


