<hr />
<p>layout: post
title: 双向链表总结
date: 2014-08-14 22:41
—</p>

<p><img src="http://www.ashliu.com:8080/uploads/460220146388-1_e.jpg" alt="" /></p>

<p>图文无关，多年前买的一本书，现在唯一的作用就是给我老爸做枕头了。<br />
最近在零散的读些源码，太久不动脑经的缘故，看的吃力且缓慢，但还是有些收获，这个链表的使用方式就其中之一，之前都是看别人实现，懂了就丢下不管，没有总结也就没有进步，所以。。细思极怖，赶紧记录下。</p>

<p>双向链表大型工程都都会用到，并且都是承载的核心数据和流程，我记录下3种常见的实现方式：
###分离型方式
个人的叫法，原因是链表与其他数据是分离实现的，见代码</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct listNode {
	// 前驱节点
	struct listNode *prev;
	// 后继节点
	struct listNode *next;
	// 值
	void *value;
} listNode;

typedef struct list {
	// 表头指针
	listNode *head;
	// 表尾指针
	listNode *tail;
	// 节点数量
	unsigned long len;
	// 复制函数
	void *(*dup)(void *ptr);
	// 释放函数
	void (*free)(void *ptr);
	// 比对函数
	int (*match)(void *ptr, void *key);
} list;
</code></pre></div></div>

<p>这段code来自于redis，不得不说redis的数据结构实现之规范，让人大赞啊！<br />
这种方式的特点是链表的实现独立于用户自己的结构，程序里面直接使用的均是list或者listNode结构，用户自己的数据结构都隐藏在void *里面，不同类型的链表指向不同的用户数据结构即可。<br />
链表的操作就是标准的实现方式，数据结构的书里面都有，redis的实现当然也是美如画。(强烈推荐读一读redis source code，可以参考<a href="https://github.com/huangz1990">黄健宏君的github</a>，里面有注释版本的。)</p>

<p>###嵌入型A
libevent的实现方式，我是觉得有点花哨，但效果很不错哟，define用的快赶上template了。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define TAILQ_HEAD(name, type)				\
struct name {								\
	struct type *tqh_first;	/* first element */\
	struct type **tqh_last;	/* addr of last next element */\
}

#define TAILQ_HEAD_INITIALIZER(head)		\
	{ NULL, &amp;(head).tqh_first }

#define TAILQ_ENTRY(type)				\
struct {								\
	struct type *tqe_next;	/* next element */\
	struct type **tqe_prev;	/* address of previous next element *\
}

/* 
 * tail queue access methods 
 */
#define	TAILQ_FIRST(head)		((head)-&gt;tqh_first)
#define	TAILQ_END(head)			NULL
#define	TAILQ_NEXT(elm, field)		((elm)-&gt;field.tqe_next)
#define TAILQ_LAST(head, headname)			\
	(*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last))
/* XXX */
#define TAILQ_PREV(elm, headname, field)	\
	(*(((struct headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))
#define	TAILQ_EMPTY(head)					\
	(TAILQ_FIRST(head) == TAILQ_END(head))

#define TAILQ_FOREACH(var, head, field)	\
	for((var) = TAILQ_FIRST(head);			\
	    (var) != TAILQ_END(head);			\
	    (var) = TAILQ_NEXT(var, field))

#define TAILQ_FOREACH_REVERSE(var, head, field, headname)\
	for((var) = TAILQ_LAST(head, headname);\
	    (var) != TAILQ_END(head);			\
	    (var) = TAILQ_PREV(var, headname, field))

/*
 * Tail queue functions.
 */
#define	TAILQ_INIT(head) do {				\
	(head)-&gt;tqh_first = NULL;				\
	(head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;	\
} while (0)

#define TAILQ_INSERT_HEAD(head, elm, field) do {\
	if (((elm)-&gt;field.tqe_next = (head)-&gt;tqh_first) != NULL)\
		(head)-&gt;tqh_first-&gt;field.tqe_prev =\
		    &amp;(elm)-&gt;field.tqe_next;			\
	else								\
		(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\
	(head)-&gt;tqh_first = (elm);				\
	(elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first;\
} while (0)

#define TAILQ_INSERT_TAIL(head, elm, field) do {\
	(elm)-&gt;field.tqe_next = NULL;			\
	(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;\
	*(head)-&gt;tqh_last = (elm);				\
	(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\
} while (0)

#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {\
	if (((elm)-&gt;field.tqe_next = (listelm)-&gt;field.tqe_next) != NULL)\
		(elm)-&gt;field.tqe_next-&gt;field.tqe_prev =\
		    &amp;(elm)-&gt;field.tqe_next;			\
	else								\
		(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;\
	(listelm)-&gt;field.tqe_next = (elm);		\
	(elm)-&gt;field.tqe_prev = &amp;(listelm)-&gt;field.tqe_next;\
} while (0)

#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {\
	(elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;\
	(elm)-&gt;field.tqe_next = (listelm);		\
	*(listelm)-&gt;field.tqe_prev = (elm);	\
	(listelm)-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;\
} while (0)

#define TAILQ_REMOVE(head, elm, field) do {\
	if (((elm)-&gt;field.tqe_next) != NULL)	\
		(elm)-&gt;field.tqe_next-&gt;field.tqe_prev =\
		    (elm)-&gt;field.tqe_prev;		\
	else								\
		(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;\
	*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;\
} while (0)

#define TAILQ_REPLACE(head, elm, elm2, field) do {\
	if (((elm2)-&gt;field.tqe_next = (elm)-&gt;field.tqe_next) != NULL)\
		(elm2)-&gt;field.tqe_next-&gt;field.tqe_prev =\
		    &amp;(elm2)-&gt;field.tqe_next;		\
	else								\
		(head)-&gt;tqh_last = &amp;(elm2)-&gt;field.tqe_next;\
	(elm2)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;\
	*(elm2)-&gt;field.tqe_prev = (elm2);		\
} while (0)
</code></pre></div></div>

<p>这种实现的特点是链表的实现嵌入到了用户数据中，组成一个整体的结构，链表会指向这整个结构体，然后巧妙的通过二级指针链接起来。我在纸上画了下算法实现，发现我又重新掌握了C pointer。。
###嵌入型B
这种类型才是我最先了解的实现方式，也是linux内核的链表实现方式，有点像方案1和方案2的综合体：链表结构定义与方案1一样，但是结构嵌入了用户的数据结构，但它不是使用define来直接获取用户数据结构，而且通过计算listNode在用户数据用的偏移量，从而间接的得到用户数据指针。</p>

<p>###总结
嵌入型的都有个缺点，那就是只能链接统一类型的数据(方案B确实可以链接不同的结构，但是这样用会不会太奇怪了？)，但是对于规划好的系统，这并不是问题。总体来说都差不多，没有好坏之分，只看个人喜好了。</p>

